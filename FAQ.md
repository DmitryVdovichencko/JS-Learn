# FAQ JS.

## Types. Coercion. Типы данных. Преобразование.

### Операторы в JS

#### Сложение `+`

Операции выполняются слева направо. Если `+` унарный то сначала выполняется он, потом все остальное.

Унарный `+` преобразует в число.

Если хотя бы один из операндов является строкой, второй также будет преобразован к строке.

#### Остаток от деления `%`

#### Возведение в степень `**`

#### Оператор `,` отбрасывает все результаты выражения кроме последнего.



### Примитивные типы данных.

#### Строки. String.

Строки примитивный тип. Они неизменяемы. Методы строки не изменяют ее по месту а создают новую и возвращают ее.
Есть обычные строки и шаблонные строки. В шаблонные строки можно включать переменные.


```javascript

	const str = "Hi! I'm string";
	// инвертируем строку
	const strRev = str
	// разбиваем строку на массив символов
	.split( "" )
	// реверсируем массив символов
	.reverse()
	// объединяем массив символов обратно в строку
	.join( "" );
	console.log(strRev); 
	// шаблонные строки
	const megaStr = `Hi I'm megastring. Look what I can: boom, here is your var - ${strRev}`;
	console.log(megaStr);

```

__Методы строк__

Длина строки - `"myString".length`

Символ строки по индексу - `.charAt(0)`

Получаем подстроку - `.substring(indexA, indexB)`

Получаем подстроку - `.slice(-10) //последние 10 символов`

Получаем подстроку указывая начальный индекс и количество сиволов - `.substr(0,4) `

__Управляющие последовательности__

Перевод строки - `\n`

Табуляция - `\t`

Экранирование кавычек - `\"`

#### Map & Set

Map - коллекция ключ-значение, как объект. Разница в том, что есть возможность использовать ключи любого вида.

__Методы и свойства__

new Map() – создаёт коллекцию.

map.set(key, value) – записывает по ключу key значение value.

map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.

map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.

map.delete(key) – удаляет элемент по ключу key.

map.clear() – очищает коллекцию от всех элементов.

map.size – возвращает текущее количество элементов.

В качестве ключей в Map можно использовать даже объекты.

__Перебираем Map:__

map.keys() – возвращает итерируемый объект по ключам

map.values() – возвращает итерируемый объект по значениям

map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

__Set__

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

`new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.

`set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.

`set.delete(value)` – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.

`set.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.

`set.clear()` – удаляет все имеющиеся значения.

`set.size` – возвращает количество элементов в множестве.

#### Date & Time

<hr>

## Scopes & Closures. Области видимости и замыкания.

### Объявление переменных и функций в JS

Переменные создаются при объявлении с помощью `var` `let` и `const`. 

```javascript

	let sayHi;
	sayHi="Hi";
	

```

При объявлении переменной с помощью `let`:

1. Лексическое окружение пустое

2. Объявляется переменная `let sayHi`, т.к. ей пока не присвоено значение, она инициализируется значением `undefined`

3. Присваевается значение `Hi`



### Область видимости (Scope) в JS

Создать функцию можно с помощью Function Declaration или Function Expression.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться. Аналогично себя ведут функции-стрелки.

Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

В JS у каждой функции есть свое лексическое окружение. Там хранятся локальные переменные и ссылка на внешнее окружение.
При каждом вызове функции создается свое лексическое окружение. 

Скрытое свойство указывающее на место создания функции - `[[Environment]]`


### Замыкания

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
В JavaScript, все функции изначально являются замыканиями.

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.


__Исключение__

Когда функция создаётся с использованием new Function, в её `[[Environment]]` записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому, такая функция имеет доступ только к глобальным переменным.


<hr>

## This. Контекст выполнения.

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this и прочую служебную информацию.


Механизм `this` помогает передать ссылку на объект, что ведет к более чистому коду и простому многократному использованию функций.

__4 правила привязки this__:

1. Стандартная привязка `this`.

_Применение:_ 

В случае отдельного вызова функции. Общий случай когда остальные правила не работают. В режиме `"use strict"` эта привязка не работает.

_Объект на который указывает `this`_: 

`this` будет указывать на то место, где вызвана функция (в  случае глобальной области видимости - объект `global`)

***


2. Неявная привязка `this`.

_Применение:_ 

Когда функция вызывается в контексте объекта созданного или уже существующего.Сначала функция объявляется а затем в свойство объекта добавляется ссылка на эту функцию.

_Объект на который указывает `this`_: 

`this` будет указывать на тот объект, в контексте которого вызвана функция.

_Замечания:_

* Если имеет место цепочка из двух объектов `this` укажет на последний
* Утеря неявной привязки происходит если: 
1. Несмотря на объявление в объекте, функция будет вызвана в глобальной области видимости. А значит, она будет запрашивать переменные из глобальной области.
2. В случае передачи колбэка функции.

***

3. Явная привязка
С неявной привязкой мы должны менять объект в том плане, что необходимо включить ссылку на саму функцию в объект и использовать это свойство-ссылку на функцию, чтобы привязать this к объекту.
Но что 

_Применение:_ 

Если нам нужно сделать привязку без назначения свойства, ссылающегося на функцию. Для этого есть методы call(..) и apply(..). Вот как они работают. Оба метода принимают параметром объект, который будет использоваться как this. И затем, вызывают эту функцию уже с определенным this.


_Объект на который указывает `this`_: 

`this` будет указывать на тот объект, для которого вызваны методы `call` или `apply`.

_Замечания:_

Не решает проблем с потерей привязки.

***


4. Привязка с помощью конструктора `new`

_Применение:_

В JS конструкторы - это функции, которые вызываются с оператором new перед ними.
Что происходит при вызове конструктора:
1. Из воздуха создается новый объект
2. Вновь созданный объект получает ссылку на `[[Prototype]]`
3. Этот объект привязан к `this` для того вызова функции 
4. До тех пор, пока функция не возвращает свой альтернативный объект, вызов функции с `new` автоматически вернет вновь созданный объект.

<hr>

## Массивы. Методы массивов.



## Objects & Prototypes. Работаем с объектами. Прототипирование и классы.

Объекты - коллекции для хранения значений. Свойства объекта представлены в виде пары ключ - значение.

__Ключ__ - строка (имя свойства), __значение__ - может быть чем угодно.

```javascript

// Создаем объект
let user = new Object(); // синтаксис "конструктор объекта"
let user = {
	name: "Dimetrio",
	role: "forward",
	age: 30,
	"favorite music": "rock"
	};  // синтаксис "литерал объекта"

// Обращаемся к свойствам

console.log(user.age);
console.log(user["favorite music"]);

// удаляем свойство
delete user.name;
console.log(user.name); //undefined

// проверяем наличие свойства

"drugs" in user; //false
"role" in user; //true

// проходим по свойствам объекта

for (key in user){
	console.log(`${key}:${user[key]}`);
}

```
Свойства объекта упорядочиваются в порядке создания, если они не целочисленные: в этом случае они будут упорядочены по возрастанию.
__При сравнении объектов нет разницы `==` или `===`. два объекта равны только если это один и тот же объект.__

__Клонируем объект__

Если попытаться присвоить новому объекту другой объект то ему будет присвоена лишь ссылка на него. Но что если нам нужно скопировать все свойства со значениями в другой объект?

Можно перебрать свойства через `for in`

Или использовать `Object.assign(destObj, srcObj1, srcObj2, srcObj3)` здесь исходные объекты будут объединены существующие свойства перезаписаны.

Если свойство объектв содержит не примитивное значение а, например, другой объект это не сработает. Надо использовать глубокое копирование с проверкой не является ли значение свойства объектом.

__Геттеры и сеттеры__

Допустим нам нужно манипулировать значениями свойств объекта, чтобы присваивать и получать какие-нибудь сложные значения.

```javascript
let user = {
  name: "John",
  surname: "Smith",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
}
// читаем свойство с помощью геттера
console.log(user.fullName);
// записываем свойство и user.name user.surname обновятся с помощью сеттера
user.fullName = "Dimetrio Vdovichetti"

// Или можем добавить свойства - аксессоры с помощью дескриптора

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});
```

### Прототипы

В программировании нам часто необходимо создавать подобные объекты на основе одного экземпляра. Как пирог по рецепту.
В этом нам поможет прототипное наследование.

В JS объекты имеют скрытое свойство [[Prototype]] оно указывает либо на объект либо на null.

```javascript

let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
// делаем прототип для rabbit через .__proto__ - геттер/сеттер для [[Prototype]]

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true


```

Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не не сеттер).
__Неважно, где находится метод: в объекте или его прототипе. При вызове метода, `this` — всегда объект перед точкой.__
Если мы вызываем `obj.method()`, а метод взят из прототипа, то this все равно ссылается на `obj`. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Свойство `.prototype` используется при работе конструктора

```javascript

let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;
// при вызове конструктора создается объект для которого назначен прототип
let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

```

### Классы

Классы используем для создания новых объектов как конструкторы.

```javascript
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Использование:
let user = new User("Dimon");
user.sayHi();

```

В JS класс - это разновидность функции.
1. Создаем функцию `User`. Код функции берем из `constructor`
2. Сохраняем все методы в User.prototype

При вызове new User методы будут взяты из прототипа.

## Arrays. Массивы и методы массивов.

Шпаргалка по методам массива:

Для добавления/удаления элементов:

`push (...items)` – добавляет элементы в конец,
`pop()` – извлекает элемент с конца,
`shift()` – извлекает элемент с начала,
`unshift(...items)` – добавляет элементы в начало.
`splice(pos, deleteCount, ...items)` – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
`slice(start, end)` – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
`concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

`indexOf/lastIndexOf(item, pos)` – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
`includes(value)` – возвращает true, если массив имеет значение value, в противном случае false.
`find/filter(func)` – фильтрует элементы через функцию и отдаёт первые/все значения, которые при прохождении через неё возвращают true.
`findIndex` похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

`forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

`map(func)` – создаёт новый массив из результатов вызова func для каждого элемента.
`sort(func)` – сортирует массив на месте, а потом возвращает его.
`reverse()` – на месте меняет порядок следования элементов на противоположный и возвращает изменённый массив.
`split/join` – преобразует строку в массив и обратно.
`reduce(func, initial)` – вычисляет одно значение из всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

`Array.isArray(arr)` проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

`arr.some(fn)/arr.every(fn)` проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты являются true, метод возвращает true, иначе false.

`arr.fill(value, start, end)` – заполняет массив повторяющимися value, начиная с индекса start до end.

`arr.copyWithin(target, start, end)` – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

## Async in JS. Асинхронность в JS.

### О цикле событий


[Перевод доклада Филипа Робертса с JSConf](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

V8 - движок - среда выполнения JS кода в браузере. Он состоит из кучи __`heap`__ - это динамически распределяемая память и стек вызовов __`callstack`__ - здесь мы можем посмотреть какая функция какую вызвала.

WebAPIs - расширения браузера: __`DOM ajax setTimeout`__

event loop - цикл событий.

JS - однопоточная среда выполнения runtime: одна инструкция за раз.

CallStack - стэк вызовов структура данных которая содержит данные о том в каком месте мы находимся.
Стэк может быть переполнен если например бесконечно выполнять рекурсию.

Что происходит когда мы вызываем setTimeout с колбэком:

Параллелизм движок JS однопоточен но мы работаем в браузере а там есть API и это по сути потоки которым мы можем отправлять запросы.

В коде вызывается setTimeout и помещается в стэк вызовов.
Поскольку это setTimeout происходит обращение к webapi - взводится таймер, setTimeout убираем из стэка вызовов продолжая выполнение кода.
Тем временем webapi заканчивает свою работу и результат помещается в очередь task queue.
Как только стек пуст event loop видит что в очереди задач есть код для обработки и помещает его в стэк вызовов.

### Callbacks

### Promises

### Async/await



## DOM, events, JSONP, CORS, AJAX, fetch. Работаем в браузере.

Данный раздел подскажет о работе JS в окружении браузера. (JS также может работать на сервере - NodeJS или даже на десктопе)

При работ с JS в браузере имеется корневой объект window, который выступает в 2 ролях:

1. Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
2. Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

### DOM - Document Object Model

Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.






## React.


### Состояние

#### Работаем с состоянием в React: 4 важных принципа.

[Original article from FreeCodeCamp](https://www.freecodecamp.org/news/handling-state-in-react-four-immutable-approaches-to-consider-d1f5c00249d5/)

На сегодня, возможно самая сложная тема для понимания в React - это состояние: `state`.

Представим, у вас есть форма для редактирования пользователем. Распространенный подход: создать один обработчик изменений, чтобы работать с изменением любого поля формы. 

Выглядит это примерно так:

```javascript

updateState(event) {
 const {name, value} = event.target;
 let user = this.state.user; // это ссылка, не копия...
 user[name] = value; // так что меняем состояние?
 return this.setState({user});
}

```

О четвертой строке кода стоит поволноваться. Четвертая строка действительно меняет состояние `state`, потому что переменная `user` ссылается на `state`. В react состояние трактуется как неизменное.

Из [документации React](https://facebook.github.io/react/docs/react-component.html#state):

> Никогда не меняйте `this.state` напрямую, т.к. вызов `setState()` в итоге может перезаписать те изменения, что вы сделали. 
Работайте с состоянием `this.state`, как будто оно неизменно. 

Почему?

`setState` работает под капотом. Это означает что принудительное изменение состояния `state` может быть перезаписано когда выполнится `setState`.
Если вы объявили метод `shouldComponentUpdate`, вы не можете использовать проверку на равенство `===` внутри, т.к. ссылка на объект не изменится. Так что вышеупомянутый метод может еще и повлиять на производительность.
Вобщем, примеры выще часто работают нормально, но чтобы избежать крайних случаев, работайте с состоянием как будто оно неизменно. 

Есть четыре способа правильной работы с состоянием `state`:

__Способ #1: `Object.assign`__

`Object.assign` создает копию объекта. Первый параметр указывает куда мы будем его копировать, остальные параметры это объекты которые мы хотим скопировать. Если исправить пример выше то изменения коснуться строки 3:

```javascript
updateState(event) {
 const {name, value} = event.target;
 let user = Object.assign({}, this.state.user);
 user[name] = value;
 return this.setState({user});
}
```

В строке 3, я говорю "создай новый пустой объект и добавь туда все свойства из `this.state.user`". В результате получится отдельная копия объекта `user` который хранится в `state`.
Теперь я могу спокойно менять объект в строке 4 - это полностью независимый объект от того, что хранится в `state`.

Убедитесь что есть полифилл для метода `Object.assign` т.к. он не поддерживается в IE и не транспилируется Babel.

4 источника для ознакомления:

[object-assign](https://www.npmjs.com/package/object-assign)

[The MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

[Babel Polyfill](https://babeljs.io/docs/usage/polyfill/)

[Polyfill.io](https://polyfill.io/v2/docs/features/#Object_assign)

__Способ #2: `Object Spread`__

Реализация `Object spread` на данный момент находится на стадии 3 и эта возможность языка может быть транспилирована Babel.
Этот способ более краткий:

```javascript
updateState(event) {
 const {name, value} = event.target;
 let user = {...this.state.user, [name]: value};
 this.setState({user});
}
```

В строке 3, я говорю "Используя все свойства `this.state.user` для создания нового объекта, затем установи для свойства `[name]` новое значение из `event.target.value`". Таким образом этот метод похож на применение `Object.assign`, но он имеет 2 преимущества:

-[x] Не требуются полифилы, Babel может транспилировать код
-[x] Более краткая форма записи

Можно даже использовать деструктуризацию и уместить все в одну строку:

```javascript
updateState({target}) {
 this.setState({user: {...this.state.user, [target.name]: target.value}});
}
```
Я деструктурировал объект `event` для получения ссылки на `event.target`. Затем я объявляю что состояние `state` должно быть копией `this.state.user` с актуальным значением свойства `[target.name]`. Получилось лаконичненько, пожалуй это мой любимый способ для обработчиков изменений.

Эти два способа самые распространенные и простые методы поддержки состояния `state` неизменным. Хотите больше полномочий при работе с состоянием? Тогда посмотрите на следующие два способа.

__Способ #3: `Immutability Helper`__


[Immutability-helper](https://github.com/kolodny/immutability-helper) внешняя библиотека для копирования данных без изменения исходных данных. Эта библиотека представлена в документации [React](https://facebook.github.io/react/docs/update.html).

```javascript
// сначала импортируем библиотеку:
import update from 'immutability-helper';

updateState({target}) {
 let user = update(this.state.user, {$merge: {[target.name]: target.value}});
 this.setState({user});
}
```

В строке 5, я вызываю `merge` - одну из команд `immutability-helper`. Как и в случае с `Object.assign`, первым параметром я передаю целевой объект, а затем определяю свойство, которое будет добавлено и объединено.

Правда, в случае с `immutability-helper` есть больше возможностей. Здесь используется синтаксис вдохновленный языком запросов `MongoDB`, что предосталяет множество мощных способов для работы с неизменяемыми данными.


__Способ #4: `Immutable.js`__

Хотите программно применять неизменность? Посмотрите на [immutable.js](https://facebook.github.io/immutable-js/). Эта библиотека поддерживает неизменные структуры данных.


Пример с использованием неизменяемой `map`:

```javascript
// Сначала импортируем библиотеку
import { Map } from 'immutable';

// Затем в конструкторе...
this.state = {
  // создаем неизменяемый map в состоянии state с помощью immutable.js
  user: Map({ firstName: 'Cory', lastName: 'House'})
};

updateState({target}) {
 // эта строка вернет новый объект  при этом неизменяемый map хранится в state.
 let user = this.state.user.set(target.name, target.value);
 this.setState({user});
}

```
Три шага для использования `immutable`:

Импортируем `immutable`.
Устанавливаем `state` в неизменяемый `map` в `constructor`
Используем метод `set` в обработчике изменений для создания новой копии объекта `user`
Вся красота `immutable.js` в том, что : если попытаться изменить `state` напрямую, возникнет ошибка. С предыдущими способами, легко об этом забыть, и React не предупредит вас, когда вы попытаетесь изменить `state` напрямую.

Недостатки `immutable`?

Раздуваем бандл. `Immutable.js` добавляет 57K в минифицированном виде. [Использование библиотек типа Preact могут заменить React всего 3К](https://preactjs.com/), что довольно тяжело принять.
Синтаксис. Вам придется ссылаться на свойства объекта через строки и точно также вызывать методы вместо доступа напрямую. Я предпочитаю использовать `user.name` чем `user.get('name')`.
YATTL (Yet another thing to learn) - Еще одна вещь для изучения - любому кто присоединится к вашей команде потребуется изучить еще один API для доступа и записи данных также как и новые типы данных.

Парочка альтернатив:

- [seamless-immutable](https://github.com/rtfeldman/seamless-immutable)
- [react-copy-write](https://github.com/aweary/react-copy-write)

__Предупреждение: Берегитесь Вложенных Объектов!__

Варианты #1 и #2 (`Object.assign`  `Object spread`) делают только поверхностную копию. Так что если ваш объект содержит вложенные объекты, они будут скопированы по ссылке, а не по значению. В этом случае если вы измените вложенный объект, вы повлияете и на исходный вложенный объект. ?

Будьте хирургиески аккуратны с тем, что копируете. Не копируйте все подряд. Копируйте объекты,которые изменились. [Immutability-helper](https://github.com/kolodny/immutability-helper) легко это делает. Также как и альтернативы [immer](https://github.com/mweststrate/immer), [updeep](https://github.com/substantial/updeep), или [вот длинный список других вариантов](https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities).

Вы можете поддаться искушению использовать инструменты глубокого слияния, например [clone-deep](https://www.npmjs.com/package/clone-deep) или [lodash.merge](https://lodash.com/docs/#merge), но __избегайте глубокого копирования__.

- Глубокое копирование дорого обходится
- Глубокое копирование нерационально ( в отличие от копирования только того, что изменилось)
- Глубокое копирование  провоцирует необязательный рендеринг, т.к. React думает что все изменилось хотя возможно фактически изменился только определенный дочерний объект.

Спасибо Дэну Абрамову за рекомендации, которые я указал выше.

__Последний совет: Подумайте над использованием функции `setState`__

Одна загвоздка может вас зацепить:

>`setState()` не изменяет состояние `this.state` немедленно, но создает ожидание перехода состония. Попытка доступа к `this.state` после вызова этого метода потенциально может вернуть существующее значение.


Как только запустится вызов `setState`, код вроде этого приведет к багу:

updateState({target}) {
 this.setState({user: {...this.state.user, [target.name]: target.value}});
 doSomething(this.state.user) // упс, setState просто запланировал изменение состояния, так что this.state.user может вернуть еще старое значение
}
Если вы хотите запустить код после завершения вызова `setState`, используйте колбэк `setState`:

updateState({target}) {
   this.setState((prevState) => {
     const updatedUser = {...prevState.user, [target.name]: target.value}; // используем предыдущее значение в state для создания нового state...     
     return { user: updatedUser }; // И то что вернется будет назначено как новое состояние state
   }, () => this.doSomething(this.state.user); // Теперь я могу спокойно использовать новое состояние state для обработки в другой функции...
     );
 }

__Мой выбор__

Я предаочитаю простоту и легкость второго варианта: `Object spread`. Он не требует полифиллов или сторонних библиотек, я могу объявлять обработчик изменений в одну строку и могу позаботиться только о том, что изменяется. Что касается работы с вложенными объектами я бы предпочел [Immer](https://github.com/mweststrate/immer)



## Redux.

## Instruments: npm, yarn, webpack.

## Data structures & algorythms.

## Patterns.




