# FAQ JS.

## Types. Coercion. Типы данных. Преобразование.

### Операторы в JS

#### Сложение `+`

Операции выполняются слева направо. Если `+` унарный то сначала выполняется он, потом все остальное.

Унарный `+` преобразует в число.

Если хотя бы один из операндов является строкой, второй также будет преобразован к строке.

#### Остаток от деления `%`

#### Возведение в степень `**`

#### Оператор `,` отбрасывает все результаты выражения кроме последнего.



### Примитивные типы данных.

#### Строки. String.

Строки примитивный тип. Они неизменяемы. Методы строки не изменяют ее по месту а создают новую и возвращают ее.
Есть обычные строки и шаблонные строки. В шаблонные строки можно включать переменные.


```javascript

	const str = "Hi! I'm string";
	// инвертируем строку
	const strRev = str
	// разбиваем строку на массив символов
	.split( "" )
	// реверсируем массив символов
	.reverse()
	// объединяем массив символов обратно в строку
	.join( "" );
	console.log(strRev); 
	// шаблонные строки
	const megaStr = `Hi I'm megastring. Look what I can: boom, here is your var - ${strRev}`;
	console.log(megaStr);

```

__Методы строк__

Длина строки - `"myString".length`

Символ строки по индексу - `.charAt(0)`

Получаем подстроку - `.substring(indexA, indexB)`

Получаем подстроку - `.slice(-10) //последние 10 символов`

Получаем подстроку указывая начальный индекс и количество сиволов - `.substr(0,4) `

__Управляющие последовательности__

Перевод строки - `\n`

Табуляция - `\t`

Экранирование кавычек - `\"`

#### Map & Set

Map - коллекция ключ-значение, как объект. Разница в том, что есть возможность использовать ключи любого вида.

__Методы и свойства__

new Map() – создаёт коллекцию.

map.set(key, value) – записывает по ключу key значение value.

map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.

map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.

map.delete(key) – удаляет элемент по ключу key.

map.clear() – очищает коллекцию от всех элементов.

map.size – возвращает текущее количество элементов.

В качестве ключей в Map можно использовать даже объекты.

__Перебираем Map:__

map.keys() – возвращает итерируемый объект по ключам

map.values() – возвращает итерируемый объект по значениям

map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

__Set__

Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.

Его основные методы это:

`new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.

`set.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.

`set.delete(value)` – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.

`set.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.

`set.clear()` – удаляет все имеющиеся значения.

`set.size` – возвращает количество элементов в множестве.

#### Date & Time

<hr>

## Scopes & Closures. Области видимости и замыкания.

### Объявление переменных и функций в JS

Переменные создаются при объявлении с помощью `var` `let` и `const`. 

```javascript

	let sayHi;
	sayHi="Hi";
	

```

При объявлении переменной с помощью `let`:

1. Лексическое окружение пустое

2. Объявляется переменная `let sayHi`, т.к. ей пока не присвоено значение, она инициализируется значением `undefined`

3. Присваевается значение `Hi`



### Область видимости (Scope) в JS

Создать функцию можно с помощью Function Declaration или Function Expression.

Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться. Аналогично себя ведут функции-стрелки.

Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

В JS у каждой функции есть свое лексическое окружение. Там хранятся локальные переменные и ссылка на внешнее окружение.
При каждом вызове функции создается свое лексическое окружение. 

Скрытое свойство указывающее на место создания функции - `[[Environment]]`


### Замыкания

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. 
В JavaScript, все функции изначально являются замыканиями.

То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]` и все они могут получить доступ к внешним переменным.


__Исключение__

Когда функция создаётся с использованием new Function, в её `[[Environment]]` записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное. Поэтому, такая функция имеет доступ только к глобальным переменным.


<hr>

## This. Контекст выполнения.

Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение this и прочую служебную информацию.


Механизм `this` помогает передать ссылку на объект, что ведет к более чистому коду и простому многократному использованию функций.

__4 правила привязки this__:

1. Стандартная привязка `this`.

_Применение:_ 

В случае отдельного вызова функции. Общий случай когда остальные правила не работают. В режиме `"use strict"` эта привязка не работает.

_Объект на который указывает `this`_: 

`this` будет указывать на то место, где вызвана функция (в  случае глобальной области видимости - объект `global`)

***


2. Неявная привязка `this`.

_Применение:_ 

Когда функция вызывается в контексте объекта созданного или уже существующего.Сначала функция объявляется а затем в свойство объекта добавляется ссылка на эту функцию.

_Объект на который указывает `this`_: 

`this` будет указывать на тот объект, в контексте которого вызвана функция.

_Замечания:_

* Если имеет место цепочка из двух объектов `this` укажет на последний
* Утеря неявной привязки происходит если: 
1. Несмотря на объявление в объекте, функция будет вызвана в глобальной области видимости. А значит, она будет запрашивать переменные из глобальной области.
2. В случае передачи колбэка функции.

***

3. Явная привязка
С неявной привязкой мы должны менять объект в том плане, что необходимо включить ссылку на саму функцию в объект и использовать это свойство-ссылку на функцию, чтобы привязать this к объекту.
Но что 

_Применение:_ 

Если нам нужно сделать привязку без назначения свойства, ссылающегося на функцию. Для этого есть методы call(..) и apply(..). Вот как они работают. Оба метода принимают параметром объект, который будет использоваться как this. И затем, вызывают эту функцию уже с определенным this.


_Объект на который указывает `this`_: 

`this` будет указывать на тот объект, для которого вызваны методы `call` или `apply`.

_Замечания:_

Не решает проблем с потерей привязки.

***


4. Привязка с помощью конструктора `new`

_Применение:_

В JS конструкторы - это функции, которые вызываются с оператором new перед ними.
Что происходит при вызове конструктора:
1. Из воздуха создается новый объект
2. Вновь созданный объект получает ссылку на `[[Prototype]]`
3. Этот объект привязан к `this` для того вызова функции 
4. До тех пор, пока функция не возвращает свой альтернативный объект, вызов функции с `new` автоматически вернет вновь созданный объект.

<hr>

## Массивы. Методы массивов.



## Objects & Prototypes. Работаем с объектами. Прототипирование и классы.

Объекты - коллекции для хранения значений. Свойства объекта представлены в виде пары ключ - значение.

__Ключ__ - строка (имя свойства), __значение__ - может быть чем угодно.

```javascript

// Создаем объект
let user = new Object(); // синтаксис "конструктор объекта"
let user = {
	name: "Dimetrio",
	role: "forward",
	age: 30,
	"favorite music": "rock"
	};  // синтаксис "литерал объекта"

// Обращаемся к свойствам

console.log(user.age);
console.log(user["favorite music"]);

// удаляем свойство
delete user.name;
console.log(user.name); //undefined

// проверяем наличие свойства

"drugs" in user; //false
"role" in user; //true

// проходим по свойствам объекта

for (key in user){
	console.log(`${key}:${user[key]}`);
}

```
Свойства объекта упорядочиваются в порядке создания, если они не целочисленные: в этом случае они будут упорядочены по возрастанию.
__При сравнении объектов нет разницы `==` или `===`. два объекта равны только если это один и тот же объект.__

__Клонируем объект__

Если попытаться присвоить новому объекту другой объект то ему будет присвоена лишь ссылка на него. Но что если нам нужно скопировать все свойства со значениями в другой объект?

Можно перебрать свойства через `for in`

Или использовать `Object.assign(destObj, srcObj1, srcObj2, srcObj3)` здесь исходные объекты будут объединены существующие свойства перезаписаны.

Если свойство объектв содержит не примитивное значение а, например, другой объект это не сработает. Надо использовать глубокое копирование с проверкой не является ли значение свойства объектом.

__Геттеры и сеттеры__

Допустим нам нужно манипулировать значениями свойств объекта, чтобы присваивать и получать какие-нибудь сложные значения.

```javascript
let user = {
  name: "John",
  surname: "Smith",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
}
// читаем свойство с помощью геттера
console.log(user.fullName);
// записываем свойство и user.name user.surname обновятся с помощью сеттера
user.fullName = "Dimetrio Vdovichetti"

// Или можем добавить свойства - аксессоры с помощью дескриптора

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});
```

### Прототипы

В программировании нам часто необходимо создавать подобные объекты на основе одного экземпляра. Как пирог по рецепту.
В этом нам поможет прототипное наследование.

В JS объекты имеют скрытое свойство [[Prototype]] оно указывает либо на объект либо на null.

```javascript

let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};
// делаем прототип для rabbit через .__proto__ - геттер/сеттер для [[Prototype]]

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true


```

Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не не сеттер).
__Неважно, где находится метод: в объекте или его прототипе. При вызове метода, `this` — всегда объект перед точкой.__
Если мы вызываем `obj.method()`, а метод взят из прототипа, то this все равно ссылается на `obj`. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Свойство `.prototype` используется при работе конструктора

```javascript

let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;
// при вызове конструктора создается объект для которого назначен прототип
let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

```

### Классы

Классы используем для создания новых объектов как конструкторы.

```javascript
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Использование:
let user = new User("Dimon");
user.sayHi();

```

В JS класс - это разновидность функции.
1. Создаем функцию `User`. Код функции берем из `constructor`
2. Сохраняем все методы в User.prototype

При вызове new User методы будут взяты из прототипа.

## Arrays. Массивы и методы массивов.

Шпаргалка по методам массива:

Для добавления/удаления элементов:

`push (...items)` – добавляет элементы в конец,
`pop()` – извлекает элемент с конца,
`shift()` – извлекает элемент с начала,
`unshift(...items)` – добавляет элементы в начало.
`splice(pos, deleteCount, ...items)` – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
`slice(start, end)` – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
`concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

`indexOf/lastIndexOf(item, pos)` – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
`includes(value)` – возвращает true, если массив имеет значение value, в противном случае false.
`find/filter(func)` – фильтрует элементы через функцию и отдаёт первые/все значения, которые при прохождении через неё возвращают true.
`findIndex` похож на find, но возвращает индекс вместо значения.
Для перебора элементов:

`forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.
Для преобразования массива:

`map(func)` – создаёт новый массив из результатов вызова func для каждого элемента.
`sort(func)` – сортирует массив на месте, а потом возвращает его.
`reverse()` – на месте меняет порядок следования элементов на противоположный и возвращает изменённый массив.
`split/join` – преобразует строку в массив и обратно.
`reduce(func, initial)` – вычисляет одно значение из всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
Дополнительно:

`Array.isArray(arr)` проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

`arr.some(fn)/arr.every(fn)` проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты являются true, метод возвращает true, иначе false.

`arr.fill(value, start, end)` – заполняет массив повторяющимися value, начиная с индекса start до end.

`arr.copyWithin(target, start, end)` – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

## Async in JS. Асинхронность в JS.

### О цикле событий


[Перевод доклада Филипа Робертса с JSConf](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

V8 - движок - среда выполнения JS кода в браузере. Он состоит из кучи __`heap`__ - это динамически распределяемая память и стек вызовов __`callstack`__ - здесь мы можем посмотреть какая функция какую вызвала.

WebAPIs - расширения браузера: __`DOM ajax setTimeout`__

event loop - цикл событий.

JS - однопоточная среда выполнения runtime: одна инструкция за раз.

CallStack - стэк вызовов структура данных которая содержит данные о том в каком месте мы находимся.
Стэк может быть переполнен если например бесконечно выполнять рекурсию.

Что происходит когда мы вызываем setTimeout с колбэком:

Параллелизм движок JS однопоточен но мы работаем в браузере а там есть API и это по сути потоки которым мы можем отправлять запросы.

В коде вызывается setTimeout и помещается в стэк вызовов.
Поскольку это setTimeout происходит обращение к webapi - взводится таймер, setTimeout убираем из стэка вызовов продолжая выполнение кода.
Тем временем webapi заканчивает свою работу и результат помещается в очередь task queue.
Как только стек пуст event loop видит что в очереди задач есть код для обработки и помещает его в стэк вызовов.

 


## DOM, events, JSONP, CORS, AJAX, fetch. Работаем в браузере.




## React.

## Redux.

## Instruments: npm, yarn, webpack.

## Data structures & algorythms.

## Patterns.




