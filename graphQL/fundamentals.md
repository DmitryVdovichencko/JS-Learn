
<img src="https://www.howtographql.com/static/howtographql.d1a2e5b4.svg" width="48" style="display:inline-block; float:left;"> 

# Основы GraphQL
## Что это и зачем тебе GraphQL?
GraphQL новый стандарт API (application programming interface — "программный интерфейс приложения"), который является более эффективной, мощной и гибкой альтернативой архитектуры REST (Representational State Transfer — "передача состояния представления").
GraphQL был разработан Facebook и является языком запросов для API.
API определяет каким образом клиент может получить данные с сервера.

Зачем был разработан GraphQL?

* Постоянный рост мобильного траффика :iphone: привел к необходимости эффективной загрузки данных.
> GraphQL минимизирует объем данных, которые нужно передать по сети и таким образом, улучшает использование приложений в условиях растущего мобильного траффика.

* Многообразие различных фронтэнд фреймворков и платформ
>  Огромное количество фронтэнд фреймворков и платформ которые управляют клиентскими приложениями делает достаточно трудоемким и сложным процессом создание и обслуживание одного API который будет удовлетворять всем требованиям. С GraphQL, каждый клиент может получить доступ к определенным данным, которые ему необходимы.

* Быстрая разработка и добавление новых возможностей
>  При использовании REST APIs, способ которым данные предоставляются сервером часто требуют модификации для соответствия специфическим требованиям и изменениям на стороне клиента.

## GraphQL лучше чем REST

### Сравнение получения данных с REST и GraphQL

При использовании REST API мы обычно собираем данные получая доступ к многочисленным конечным точкам.
Например, это может быть `/users/<id>` для доступа к данным пользователя. Потом нам понадобится обратиться к конечной точке `users/<id>/posts` , которая вернет все его посты. Ну и напоследок обратимся к `/users/<id>/followers` чтобы получить список подписчиков пользователя.

![REST fetching](https://i.imgur.com/VIWd5I5.png "Logo Title Text 1")

При использовании REST потребовалось три запроса для получения необходимой информации и, кстати, каждй раз мы получили немного лишних данных, которые мы не запрашивали.

С другой стороны, при использовании GraphQL, мы отправляем единственный запрос GraphQL серверу который включает в себя все требования для запрашиваемых данных. Сервер отправляет в ответ JSON объект где все требуемые поля уже заполнены.

![GraphQL fetching](https://i.imgur.com/uY50GHz.png "Logo Title Text 1")

### Итак больше никаких лишних данных и никакого недостатка при их получении :sweat_smile:. 

Одна из самых больших проблем REST архитектуры в том, что когда клиент загружает данные по ссылкам ему возвращаются фиксированные структуры данных, и довольно сложно разаработать API таким способом, чтобы клиенты получали только те данные, которые им необходимы.

В результате при загрузке JSON с данными пользователей загрузятся все данные, а не только их имена, например. Недополучение данных возникает потому что в возвращаемой информации недостаточно данных, например отсутствуют посты пользователя, поэтому нужно делать еще один запрос.

### Быстрая разработка Frontend

При использовании REST архитектуры любое изменение клиентской части, UI интерфейса чаще всего потребует изменение backend части.
С GraphQL можно производить изменения на стороне клиента без дополнительной работы на сервере.
Кроме того GraphQL позволяет анализировать статистику запросов на сервер и получение данных.

### Преимущества применения Схемы и Системы типов данных

GraphQL использует строгую типизацию для определения возможностей API. Все типы, которые представлены API внесены в схему с использованием GraphQL SDL (Schema Definition Language). Эта схема составляет "контракт" между клиентом и сервером для определения того, каким образом клиент получит доступ к данным.

После того как схема определена, команды, работающие над бэкендом и фронтендом могут делать свою работу, не договариваясь об обмене данными, поскольку теперь будет определена структура данных для передачи по сети.

## Основы GraphQL

### Синтакис определения Схемы

GraphQL имеет собственную систему типов для определения схемы взаимодействия с API. 

Пример синтаксиса Схемы - Schema Definition Language (SDL):

``` javascript
type Person {
  name: String!
  age: Int!
}
```

Итак здесь есть поля - `name` и `age` после чего указан соответствующий полям тип `String` и `Int`. `!` означает что поле является обязательным. Есть возможность использовать относительные типы:

``` javascript
type Post {
  title: String!
  author: Person!
}

type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
```
В примере пост `Post` привязан к автору `Person`. В свою очередь `Person` содержит поле `posts` которое привязано к массиву постов `[Post!]!`.

### Получаем данные с помощью запросов.

Пример запроса для получения данных с сервера:

``` javascript
{
  allPersons {
    name
   }
}
```
В этом случае ответом будет например:

``` javascript
{
  "allPersons": [
    { "name": "Johnny" },
    { "name": "Sarah" },
    { "name": "Alice" }
  ]
}
```
В GraphQL можно запрашивать аргументы для полей если они определены в Схеме. Например может быть определен аргумент для возврата определенного числа авторов:
``` javascript
{
  allPersons(last: 2) {
    name
  }
}
```
В данном случае будут возвращены два последних автора.

### Записываем данные с помощью мутаций.

Иногда необходимо вносить изменения в данные, сохраненные на бэкенде.
С GraphQL для выполнения таких изменений используем мутации. Есть три вида мутаций:

* Создание новых данных
* Обновление существующих данных
* Удаление существующих данных

Синтаксис мутаций похож на запросы кроме наличия ключевого слова `mutation` в самом начале.

``` javascript
mutation {
    createPerson(name: "Dimas", age: 36) {
    name
    age
    id
  }
}
```
И ответ сервера будет 

``` javascript
"createPerson": {
  "name": "Dimas",
  "age": 36,
  "id": "cjrj02ahv0yr00150f5xrvasp"
}


