
# Колбэки.

Колбэк - функция, которая возвращается при обработке элемента в очереди цикла событий.

```javascript
// A
setTimeout( function(){
  // C
}, 1000 );
// B
```

В этом примере сначала выполнится `A` затем установится 1 сек таймер, выполнится `B` и наконец выполнится `С`.
Проблема использования колбэков в неоднозначности порядка выполнения кода.

```javascript
cookBreakfast( function(){
	getCoffee();

	getSandwich( function(){
		getButter();
	} )

	getFruits();
} );

eatBreakfast();
```

- [ ] `cookBreakfast` - сначала готовим завтрак

- [ ] `eatBreakfast` - затем едим завтрак
- [ ] `getCoffee` - теперь приготовим кофе
- [ ] `getSandwich` - сделаем сэндвич
- [ ] `getFruits` - достанем фрукты
- [ ] `getButter` - возьмем масло для сэндвича

Если на вид порядок очевиден и логичен, то при выполнении кода выполняется совсем другая последовательность операций и мы попадаем в "callback hell".

Итак пришло время разобраться что за колбэки и с чем их едят.

## Изучим функции высшего порядка или колбэки в JS

В JavaScript, функции в первую очередь являются объектами; т.е., функции имеют тип Object и могут использоваться также как любой другой объект (String, Array, Number, вот это всё.) т.к. фактически они и являются объектами. 

Они могут:
* Записываться в переменные
* Передаваться как аргументы для других функций
* Создаваться внутри функций
* И возвращаться при выполнении из других функций

Колбэки являются продуктом функционального программирования. Функциональное программирование предполагает использование функций 

### Что такое колбэки или функции высшего порядка?

__Колбэк, также известный как функция высшего порядка, это функция которая передается другой функции как параметр, и колбэк вызывается внутри этой другой функции.__

Посмотрим на пример с jQuery:

```javascript
//Здесь мы передаем методу click функцию, а не переменную.
//Эта функция и есть колбэк
$("#btn_1").click(function() {
  alert("Btn 1 Clicked");
});
```
Пример из чистого JavaScript:

```javascript
var friends = ["Mike", "Stacy", "Andy", "Rick"];

friends.forEach(function (eachName, index){
console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick
});
```
В обоих примерах методам передавалась анонимная функция как параметр.

### Как работают колбэки?

Когда мы передаем колбэк как  аргумент для другой функции, мы передаем только определение функции. Мы не выполняем функцию в параметре.Короче мы передаем функцию без скобок в конце, как мы обычно делаем если хотим ее вызвать.

Теперь когда функия содержит в своем параметре определение функции, она может выполнить колбэк в любое время.
Колбэк не выполняется немедленно. Он выполнится в момент, который определяет внешняя функция.

```javascript
//Анонимная функция не будет вызвана в параметре. 
//Она будет выполнена когда произойдет событие click на элементе #btn_1
$("#btn_1").click(function() {
  alert("Btn 1 Clicked");
});
```
__Колбэки являются примерами замыканий__

Когда мы передаем колбэк как аргумент для другой функции, колбэк выполнится в определенный момент внутри этой функции также как если бы он был объявлен внутри нее. И это значит что колбэки являются примерами замыкания.

### Основные принципы при применении колбэков

__Используем именнованные ИЛИ анонимные функции в качестве колбэков__
В предыдущих примерах мы использовали анонимные функции, которые определяли в параметрах внешней функции. 
Другой случай использования колбэка - создать именнованую функцию и передать ее имя в качесте параметра для внешней функции.

```javascript
// глобальная переменная
var allUserData = [];

// общая функция logStuff которвя осуществляет вывод в консоль данных
function logStuff (userData) {
    if ( typeof userData === "string")
    {
        console.log(userData);
    }
    else if ( typeof userData === "object")
    {
        for (var item in userData) {
            console.log(item + ": " + userData[item]);
        }

    }

}

// Функция, принимающая два параметра и последний является колбэком
function getInput (options, callback) {
    allUserData.push (options);
    callback (options);

}

// Когда мы вызываем функцию getInput, мы передаем logStuff в качестве параметра.
// Итак logStuff будет функцией, которую мы вызовем внутри функции getInput
getInput ({name:"Rich", speciality:"JavaScript"}, logStuff);
//  name: Rich
// speciality: JavaScript
```

__Передаем параметры колбэкам__
Раз уж колбэк это обычная функция, значит при его выполнении мы можем передать ему параметры. Мы можем передать любую переменную внешней функции или глобальную переменную.
```javascript

//Глобальная переменная
var generalLastName = "Clinton";

function getInput (options, callback) {
    allUserData.push (options);
// Передаем глобальную переменную колбэку
    callback (generalLastName, options);
}
```

__Убедись, что колбэк является функцией перед его выполнением__
Это всегда разумно - проверить, что колбэк, переданный в качестве параметра, это точно функция, перед тем как его вызовут.Также хорошая практика делать колбек опциональным (необязательным).
Отрефакторим функцию getInput:

```javascript
function getInput(options, callback) {
    allUserData.push(options);

    // убеждаемся что колбэк - функция
    if (typeof callback === "function") {
    // Мы подтвердили что колбэк можно вызвать значит вызываем
        callback(options);
    }
}
```
__Проблема с использованием методов объекта this как колбэков__
Когда колбэк является методом который использует объект `this` мы должны изменить способ вызова колбэка, чтобы сохранить контекст объекта `this`. Иначе объект `this` будет указывать на объект `window`, если колбэк передается глобальной функции.

```javascript

// Определяем объект с несколькими свойствами и методом
// Позже передадим метод как колбэк другой функции
var clientData = {
    id: 094545,
    fullName: "Not Set",
    // setUserName метод объекта clientData
    setUserName: function (firstName, lastName)  {
        // this ссылается на свойство объекта fullName 
      this.fullName = firstName + " " + lastName;
    }
}

function getUserInput(firstName, lastName, callback)  {
    // Выполняем проверку введенных firstName/lastName 

    // Теперь сохраняем имя
    callback (firstName, lastName);
}
```

Когда метод `clientData.setUserName` выполнится, `this.fullName`не присвоит значение свойству `fullName` объекта `clientData` . Вместо этого, свойство `fullName` будет назначено объекту `window`, т.к. `getUserInput` глобальная функция. Это произошло потому что в глобальных функциях `this` указывает на объект `window`.

```javascript
getUserInput ("Barack", "Obama", clientData.setUserName);

console.log (clientData.fullName);// Not Set

// Свойство fullName было назначено объекту window
console.log (window.fullName); // Barack Obama
```

__Используем `Call`или`Apply` методы для привязки this__
Мы можем исправить проблему с потерей `this` используя `call` или `apply`. Каждая функция в JS имеет два метода: `call` и `apply`. Эти методы используются для привязки объекта `this` внутри функции а также для передачи функциям аргументов.


`call` первым параметром принимает значение которое используется для привязки объекта `this` внутри функции, оставшиеся аргументы будут переданы функции как ее аргументы. 

`apply` первым параметром также принимает значение которое используется для привязки объекта `this` внутри функции, а последним праметром принимает массив аргументов (или объект аргументов) для передачи функции.

```javascript

//заметим что мы добавили функции дополнительный параметр для указания на объект для колбэка - "callbackObj"
function getUserInput(firstName, lastName, callback, callbackObj)  {
    // Выполняем проверку введенных firstName/lastName 

    // Используем Apply функцию для привязки объекта this к callbackObj
    callback.apply (callbackObj, [firstName, lastName]);
}
```

С примением `apply` функция правильно определит `this`, и мы сможем корректно выполнить колбэк для установки свойства `fullName` объекту `clientData` :

```javascript
// Передаем метод clientData.setUserName  и объект clientData как параметры. 
// Объект clientData будет использован apply для привязки this
getUserInput ("Barack", "Obama", clientData.setUserName, clientData);

// Свойство fullName объекта clientData было назначено корректно
console.log (clientData.fullName); // Barack Obama
```

